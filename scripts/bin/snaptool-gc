#!/bin/bash

set -e

# load libsnaptool
. $(dirname $BASH_SOURCE)/libsnaptool.sh

COMMAND=$(basename $BASH_SOURCE .sh)

dryrun=0

function __gen_snapshots() {
	local basedir setupfile
	basedir=$1
	setupfile=$(basename $(get_setupfile))

	local flavours="master iotbzh chromium"
	local machines="m3ulcb h3ulcb intel-corei7-64 qemux86-64 raspberrypi3"
	local tags="default devel"
	local days=545

	# "reduced" version for prototyping
	flavours="master iotbzh"
	machines="m3ulcb intel-corei7-64"
	tags="default devel"
	days=30

	for flavour in $flavours; do
		for machine in $machines; do
			for tag in $tags; do
				for day in $(seq 0 $days); do
					ts=$(date -u -d "$day days ago 12:34:56" +"%s")
					version=$(date -u "+%Y%m%d_%H%M%S" -d "@$ts")
					dir=$basedir/$flavour/$machine/$tag/$version
					echo $dir

					mkdir -p $dir
					status=ok
					[[ $(( RANDOM % 10 )) == 0 ]] && status=fail
					cat <<EOF >$dir/$setupfile
MACHINE=$machine
FLAVOUR=$flavour
TAG=$tag
BB_TS=$ts
BB_STATUS=$status
EOF
					# create 1G sparse file
					[[ ! -f $dir/payload ]] && truncate -s $(( (RANDOM + 16384)*1024*1024/4 )) $dir/payload
				done
			done
		done
	done
}

function __find_snapshots() {
	local basedir setupfile now
	basedir=$1
	setupfile=$(basename $(get_setupfile))
	now=$(date -u +%s)

	for x in $(find $basedir -name $setupfile -exec realpath {} \;); do
		( 
			. $x
			dir="${x%/*}"
			status=${BB_STATUS:-unknown}
			ts=${BB_TS:-0}
			age=$(( (now - ${BB_TS:-0})/86400 ))
			size=$(du -ms --apparent-size $dir | { read sz d; echo $sz; })
			echo "$ts:$age:$status:$size:$dir"
		)
	done
}

function __compute_retention_dates() {
	local DAYS=${1:-14}
	local WEEKS=${2:-2}
	local MONTHS=${3:-2}
	local QUARTERS=${4:-3}
	local now
	now=$(getdt "${5:-now}")
	
	function previous_sunday() {
		local cur=$1 dow
		while true; do
			dow=$(date --utc +%u -d $cur)
			[[ $dow == 7 ]] && break
			cur=$(getdt "$cur -1 day")
		done
		echo $cur
	}

	function last_sunday_previous_month() {
		local cur=$1
		cur=$(date --utc +%Y%m01 -d $cur)
		cur=$(getdt "$cur -1 day")
		cur=$(previous_sunday $cur)
		echo $cur
	}

	function last_sunday_previous_quarter() {
		local cur=$1 month qmonth
		month=$(date --utc +%m -d $cur)
		month=${month#0}
		qmonth=$(printf "%02d" $(( month-(month-1)%3 )) ) # first month of the quarter
		cur=$(date --utc +%Y${qmonth}01 -d $cur) # first day of the quarter
		cur=$(getdt "$cur -1 day")
		cur=$(previous_sunday $cur)
		echo $cur
	}

	# build the list of accepted dates
	local dates

	# last n days
	dates=$now
	for x in $(seq 2 $DAYS); do 
		now=$(getdt "$now -1 day")
		dates="$dates $now"
	done

	# find preceding sunday and take n weeks
	now=$(getdt "$now -1 day")
	now=$(previous_sunday $now)
	for x in $(seq 1 $WEEKS); do 
		dates="$dates $now"
		now=$(getdt "$now -1 week")
	done

	# find last sunday of each month in previous months
	now=$(last_sunday_previous_month $now)
	for x in $(seq 1 $MONTHS); do 
		dates="$dates $now"
		now=$(last_sunday_previous_month $now)
	done

	# find last sunday of each quarter in previous quarters
	now=$(last_sunday_previous_quarter $now)
	for x in $(seq 1 $QUARTERS); do 
		dates="$dates $now"
		now=$(last_sunday_previous_quarter $now)
	done

	echo $dates
}

function __gc_variable() {
	local basedir=$1
	local params=$2

	local days=14 weeks=2 months=2 quarters=3

	local d w m q
	if [[ "$params" == "auto" ]]; then
		# keep default values
		true
	else
	# "$d" -eq "$d" : this is a test to see if $d is an integer
		IFS=':' read d w m q <<< $params
		function __param_error() { fatal "Invalid parameter '$1' for variable GC: $params"; }

		info d=$d w=$w m=$m q=$q
		[[ $d == [1-9]*([0-9]) ]] && days=$d     || [[ -z "$d" ]] || __param_error days
		[[ $w == [0-9]*([0-9]) ]] && weeks=$w    || [[ -z "$w" ]] || __param_error weeks
		[[ $m == [0-9]*([0-9]) ]] && months=$m   || [[ -z "$m" ]] || __param_error months
		[[ $q == [0-9]*([0-9]) ]] && quarters=$q || [[ -z "$q" ]] || __param_error quarters
	fi

	info "Using variable GC with (days,weeks,months,quarters) = ($days,$weeks,$months,$quarters)"

	# compute dates to keep
	local dtkeep
	dtkeep=$(__compute_retention_dates $days $weeks $months $quarters)
	debug "Dates to keep: $dtkeep"

	local ts age status size dir totsz
	__find_snapshots $basedir | sort -rn | while IFS=':' read ts age status size dir; do
		sdt=$(getdt "@$ts") # snapshot date
		grep -q $sdt <<< $dtkeep && debug "$sdt keep $dir" || { echo $dir; debug "$sdt drop $dir"; }
	done
}

function __gc_size() {
	local basedir=$1
	local szlimit=$2

	case ${szlimit: -1} in
		T|t) szlimit=$(( ${szlimit:0:-1} * 1024 * 1024 ));;
		G|g) szlimit=$(( ${szlimit:0:-1} * 1024 ));;
		M|m) szlimit=$(( ${szlimit:0:-1} ));;
		K|k) szlimit=$(( ${szlimit:0:-1} / 1024 ));;
		B|b) szlimit=$(( ${szlimit:0:-1} / (1024 * 1024) ));;
		*) ;;
	esac
	
	local ts age status size dir totsz
	totsz=0
	__find_snapshots $basedir | sort -rn | while IFS=':' read ts age status size dir; do
		totsz=$(( $totsz + $size ))
		[[ $totsz -lt $szlimit ]] && {
			debug "totalsize=$totsz < $szlimit : keep $dir ($size)"
			continue
		}
		debug "totalsize=$totsz > $szlimit : drop $dir ($size)"
		echo $dir
	done
}

function getdt() { date --utc +%Y%m%d -d "$@" 2>/dev/null || fatal "Invalid date '$@'"; }
function getts() { date --utc +%s -d "$@" 2>/dev/null || fatal "Invalid date '$@'"; }

function __gc_date() {

	local basedir dtlimit now tslimit tsnow
	basedir=$1
	dtlimit=$(getdt "$2")
	now=$(getdt "${3:-now}")

	tslimit=$(getts "$dtlimit")
	tsnow=$(getts $now)
	[[ $tslimit -gt $tsnow ]] && fatal "Date limit '$tslimit' is not in the past (relatively to $tsnow))"

	function __dates_interval() {
		local from=$1
		local to=$2

		from=$(getdt "$from")
		to=$(getdt "$to")

		info "Computing dates from $from to $to"
		local dates="$from"

		while [[ "$from" != "$to" ]]; do
			from=$(getdt "$from +1 day")
			dates="$dates $from"
		done
		echo $dates
	}
	
	# compute dates to keep
	local dtkeep
	dtkeep=$(__dates_interval "$dtlimit" "$now")
	debug "Dates to keep: $dtkeep"

	local ts age status size dir totsz
	__find_snapshots $basedir | sort -rn | while IFS=':' read ts age status size dir; do
		sdt=$(getdt "@$ts") # snapshot date
		grep -q $sdt <<< $dtkeep && debug "$sdt keep $dir" || { echo $dir; debug "$sdt drop $dir"; }
	done
}

function __gc_remove() {
	while read victim; do
		if [[ "$dryrun" == 1 ]]; then
			echo "DRYRUN - removing $victim"
		else
			echo -n "Removing $victim ... "
			# TODO
			echo "Done"
		fi
	done
}

function command_gc() {

	function __usage() {
		cat <<EOF >&2
Usage: $COMMAND [options] 
   options:
      -n|--dryrun : do nothing
      -h|--help   : get this help
      -p|--publish-dir : publish dir to consider for GC
      -s|--size <size>  : limit on size (accepted suffixes: TtGgMmKkBb, default is MB)
         examples:
         --size 2   # 2 MB (default unit)
         --size 2M  # 2 MB
         --size 3G  # 3 GB
         --size 4T  # 4 TB
      -d|--date <date>  : limit on date (as with -d in date(1))
         examples:
         --date '1 year ago'
         --date '3 weeks ago'
         --date '20180630'
      -v|--variable <specification> : variable date distribution
         <specification> can be:
         'd'       : number of days
         'd:w'     : number of days and weeks
         'd:w:m'   : number of days, weeks and months
         'd:w:m:q' : number of days, weeks, months and quarters
         'auto'    : meaning 14 days, 2 weeks, 2 months, 3 quarters ~= 24 snapshots
EOF
	}

	local opts="-o p:,s:,d:,v:,n,h --long publish-dir:,size:,date:,variable:,dryrun,help" tmp
	tmp=$(getopt $opts -n "$COMMAND" -- "$@" 2>/dev/null) || {
		tmp=$(getopt $opts -n "$COMMAND" -- "$@" 2>&1 >/dev/null) || true
		error $tmp; _usage; return 1
	}
	eval set -- $tmp

	local method=
	local szlimit=0
	local dtlimit=0
	local varparams=auto
	local basedir=${PUBLISH[path]}

	while true; do	
		case "$1" in 
			-n|--dryrun) dryrun=1; shift;;
			-h|--help) __usage; return 0;;
			-p|--publish-dir) basedir=$2; shift 2;;
			-s|--size) [[ -n "$method" ]] && fatal "GC method already set to '$method'" ; method=size; szlimit=$2; shift 2;;
			-d|--date) [[ -n "$method" ]] && fatal "GC method already set to '$method'" ; method=date; dtlimit=$2; shift 2;;
			-v|--variable) [[ -n "$method" ]] && fatal "GC method already set to '$method'" ; method=variable; varparams=$2; shift 2;;
			--) shift; break;;
			*) fatal "Internal error";;
		esac
	done

	[[ ! -d "$basedir" ]] && fatal "No directory '$basedir' found."
	[[ -z "$method" ]] && method=variable

	#__gen_snapshots $basedir
	(case $method in
		size)
			__gc_size $basedir $szlimit
			;;
		date)
			__gc_date $basedir "$dtlimit"
			;;
		variable)
			__gc_variable $basedir $varparams
			;;
		*)
			fatal "Unknown GC method '$method'"
			;;
	esac) | __gc_remove
}

# ----------

command_gc "$@"


