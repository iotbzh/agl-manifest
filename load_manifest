#!/bin/bash 

# global variable containing the git repository where all manifests are stored
MANIFEST_URL=https://github.com/iotbzh/agl-manifest.git 

set -e 

function usage() {
	cat <<EOF >&2
$BASH_SOURCE [options]

Options:
   -f|--flavour <flavour[/tag_or_revision]>
      what flavour to us
      default: 'iotbzh'
      possible values: 'stable','unstable','testing', 'iotbzh' ... see agl-manifest git repository
   -o|--outputdir <destination_dir>
      output directory where subdirectories will be created: meta, build, ...
      default: current directory (.)
   -l|--localmirror <directory>
      specifies a local mirror directory to initialize meta, download_dir or sstate-cache
	  default: none
   -r|--remotemirror <url>
      specifies a remote mirror directory to be used at build time for download_dir or sstate-cache
	  default: none
   -p|--proprietary <directory>
      Directory containing Renesas proprietary drivers for RCar platform (2 zip files)
	  default: none
   -e|--enable <option>
      enable a specific option
	  available options: ccache
   -d|--disable <option>
      disable a specific option
	  available options: ccache
   -t|--target <name>
      target platform
	  default: porter

Example:
	$BASH_SOURCE -f iotbzh/master -o /tmp/xdt -l /ssd/mirror -p /vol/xdt/proprietary-renesas-rcar/ -t porter
	
EOF
	exit 1
}

function info() {
	echo "$@" >&2
}

TEMP=$(getopt -o f:o:l:r:p:e:d:t: --long flavour,outputdir,localmirror,remotemirror,proprietary,enable,disable,target -n $(basename $BASH_SOURCE) -- "$@")
[[ $? != 0 ]] && usage
eval set -- "$TEMP"

FLAVOUR=iotbzh
DSTDIR=.
LOCALMIRROR=
REMOTEMIRROR=
PROPRIETARY_RENESAS_DIR=
TARGET=porter
while true; do
	case "$1" in
		-f|--flavour) FLAVOUR=$2; shift 2;;
		-o|--outputdir) DSTDIR=$(cd $2 && pwd -P); shift 2;; 
		-l|--localmirror) LOCALMIRROR=$(cd $2 && pwd -P); shift 2;;
		-r|--remotemirror) REMOTEMIRROR=$2; shift 2;;
		-p|--proprietary) PROPRIETARY_RENESAS_DIR=$(cd $2 && pwd -P); shift 2;;
		-e|--enable) eval option_$2=1; shift 2;;
		-d|--disable) eval option_$2=0; shift 2;;
		-t|--target) TARGET=$2; shift 2;;
		--) shift; break;;
		*) info "Internal error"; exit 1;;
	esac
done

# no remaining args allowed
[[ $# != 0 ]] && usage

# check git presence
which git || { info "Unable to find git command."; exit 1; }

info "=============== SUMMARY =================="
for v in \
	FLAVOUR \
	DSTDIR \
	TARGET \
	MANIFEST_URL \
	LOCALMIRROR \
	REMOTEMIRROR \
	PROPRIETARY_RENESAS_DIR \
	; do
	info "$v : ${!v}"
done
info "=========================================="

################################ clone agl-manifest ############################

function clone_or_pull() {
	url=$1
	rev=${2:-}
	dir=$(basename $url .git)

	info "=== cloning $url / $rev into $PWD/$dir"
	if [[ ! -d $dir ]]; then
		git clone $url
	else
		pushd $dir >/dev/null
			git fetch --all
		popd >/dev/null
	fi

	pushd $dir >/dev/null
		git checkout -f $rev
	popd >/dev/null
}

mkdir -p $DSTDIR/meta

pushd $DSTDIR/meta >/dev/null #{
	if [[ "$FLAVOUR" =~ / ]]; then
		flavour=${FLAVOUR%%/*}
		rev=${FLAVOUR#*/}
	else
		flavour=$FLAVOUR
		rev=
	fi

	clone_or_pull $MANIFEST_URL $rev

	SRCDIR=$DSTDIR/meta/$(basename $MANIFEST_URL .git)/$flavour
	[[ ! -d $SRCDIR ]] && { info "Unable to find flavour '$flavour'"; exit 1; }
	info "=== SRCDIR: $SRCDIR"

	# use latest manifest file
	for x in $SRCDIR/*.manifest; do
		[[ -n "$MANIFEST_FILE" ]] && info "Multiple manifest files found. Skipping $MANIFEST_FILE."
		MANIFEST_FILE=$x
	done
	[[ ! -f $MANIFEST_FILE ]] && { info "Unable to find manifest file for flavour $FLAVOUR"; exit 1; }
	info "=== MANIFEST_FILE: $MANIFEST_FILE"

popd >/dev/null #}

################################ populate meta ############################

function checkout_gits() {
	local DESTDIR=$(cd ${1:-.} && pwd -P)
	LANG=

	sed 's/#.*$//g' | # suppress comments
		awk '/[^[:space:]]+/ { print "DIR  "$2; for(i=3;i<=NF;i++) { print "REPO "$i}; print "HASH "$1 }' |
		while read tag value; do
			case $tag in
				DIR)
					[[ -d "$DESTDIR/$value" ]] || mkdir "$DESTDIR/$value"
					[[ -d "$DESTDIR/$value/.git" ]] || git init "$DESTDIR/$value"
					info "=== fetch/checkout $value"
					cd "$DESTDIR/$value"
					;;
				REPO)
					name="${value%%=*}"
					url="${value#*=}"
					info "Repository: $value"
					if ! git remote | grep -q "^$name\$"; then
						git remote add "$name" "$url"
					elif ! git remote -v | awk '$1=="'$name'" && $2!="'$url'" {exit 1}'; then
						git remote set-url "$name" "$url"
					fi
					;;
				HASH)
					info "Using revision $value"
					sha="${value%%=*}"
					branch="${value#*=}"
					git fetch --all
					git checkout -f "$sha" -B "$branch"
					;;
			esac
		done
}

# init from mirror if any
for dir in ${LOCALMIRROR//:/ }; do
	if [[ -d $dir/meta ]]; then
		info "=== Copying $dir/meta to $DSTDIR/meta"
		rsync -a $dir/meta/ $DSTDIR/meta/
		break
	fi
done

pushd $DSTDIR/meta >/dev/null #{

	checkout_gits . <$MANIFEST_FILE

popd >/dev/null #}

##################################### apply patches ####################################

info "=== apply patches"
pushd $DSTDIR/meta >/dev/null #{
	for file in $SRCDIR/patches/*/*.patch; do
		# file may be the pattern itself if no matches
		if [[ -f $file ]]; then
			meta=$(basename $(dirname $file))

			info "Patching meta $meta with patch $file"

			pushd $DSTDIR/meta/$meta >/dev/null
				patch -p1 <$file
			popd >/dev/null
		fi

	done
	
popd >/dev/null #}

##################################### setup build ######################################

info "=== setup build for $TARGET"

mkdir -p $DSTDIR/build
mkdir -p $DSTDIR/downloads
mkdir -p $DSTDIR/sstate-cache

pushd $DSTDIR/meta >/dev/null #{
	case "$TARGET" in
		porter|koelsch|silk)
			if [[ -d "$PROPRIETARY_RENESAS_DIR" ]]; then
				echo "Using proprietary Renesas drivers for target $TARGET"
				# this will install the proprietary drivers at the right place and setup environment
				# XDG_DOWNLOAD_DIR is used by meta-renesas/meta-rcar-gen2/scripts/setup_mm_packages.sh script to find zip files
				export XDG_DOWNLOAD_DIR=$PROPRIETARY_RENESAS_DIR
				source $DSTDIR/meta/meta-agl/scripts/envsetup.sh $TARGET $DSTDIR/build >/dev/null
				# temp binary dir is not cleaned up
				rm -rf $DSTDIR/meta/binary-tmp
				option_proprietary=1
			else
				echo "Initializing for porter board without proprietary drivers"
				export TEMPLATECONF=$DSTDIR/meta/meta-renesas/meta-rcar-gen2/conf
				source $DSTDIR/meta/poky/oe-init-build-env $DSTDIR/build >/dev/null
			fi
			;;
		*)
			source $DSTDIR/meta/meta-agl/scripts/envsetup.sh $TARGET $DSTDIR/build >/dev/null
			;;
	esac
popd >/dev/null #}

pushd $DSTDIR/build >/dev/null #{

	info "=== conf: build.conf"

	# ----------------------- snapshot specific options -------------------------------
	cat <<EOF >conf/build.conf
# options to generate snapshots in containers

# remove intermediate files
# uncomment if work dir is to be copied
#INHERIT += "rm_work"

# download cache location
DL_DIR = "$DSTDIR/downloads"

# generate tarballs from git source directorys in download cache
# uncomment when generating a reference download cache
#BB_GENERATE_MIRROR_TARBALLS = "1"

# dump stats to be view by:
# poky/scripts/pybootchartgui/pybootchartgui.py -m 100 tmp/buildstats/<sometimestamp>
# USER_CLASSES += "buildstats"

# set state cache locations
SSTATE_DIR = "$DSTDIR/sstate-cache"
EOF

	# --------------------------- download caches ----------------------------------------

	info "=== conf: download caches"

	# local caches must be copied to current download dir to be used as a reference when copying
	for mirror in $(for x in ${LOCALMIRROR//:/ }; do echo $x/downloads; done); do
		[[ -d $mirror ]] && rsync -a ${mirror}/ $DSTDIR/downloads/
	done

	# remote cache can only be referenced
	if [[ -n "$REMOTEMIRROR" ]]; then
		# add remote mirror
		cat <<EOF >>conf/build.conf

# define remote download cache mirror
PREMIRRORS += "\
	git://.*/.*   $REMOTEMIRROR/downloads \n \
	ftp://.*/.*   $REMOTEMIRROR/downloads \n \
	http://.*/.*  $REMOTEMIRROR/downloads \n \
	https://.*/.* $REMOTEMIRROR/downloads \n"
EOF
	fi

	# ----------------------------- sstate-cache ----------------------------

	info "=== conf: sstate caches"

	# local cache copied, as previously
	for mirror in $(for x in ${LOCALMIRROR//:/ }; do echo $x/sstate-cache; done); do
		[[ -d $mirror ]] && rsync -a ${mirror}/ $DSTDIR/sstate-cache/
	done

	# remote cache, simply referenced
	if [[ -n "$REMOTEMIRROR" ]]; then
		cat <<EOF >>conf/build.conf

# define remote shared state cache mirror
SSTATE_MIRRORS += "file://.* $REMOTEMIRROR/sstate-cache/PATH \n"
EOF
	fi

	# ----------------------------------- ccache -----------------------------


	if [[ "$option_ccache" == 1 ]]; then
		info "=== conf: ccache"
		for mirror in $(for x in ${LOCALMIRROR//:/ }; do echo $x/ccache; done); do
			[[ -d $mirror ]] && rsync -a ${mirror}/ $DSTDIR/ccache/
		done
		
		mkdir -p $DSTDIR/ccache
		CCACHE_DIR=$DSTDIR/ccache ccache -M 8G # set cache max size to 8G

		cat <<EOF >>conf/build.conf

# enable CCACHE
INHERIT += "ccache"
CCACHE_DIR = "$DSTDIR/ccache"
# workaround ncurses build problem with ccache
ENABLE_WIDEC_class-native = "false"
ENABLE_WIDEC_class-nativesdk = "false"
EOF
	fi

	# ------------------------------- include build.conf in local.conf ------------------------------------
	
	info "=== conf: local.conf"

	cat <<'EOF' >>conf/local.conf
# include extra conf files
require conf/build.conf
EOF

	# --------------------------- handle extra config files coming with agl-manifest -----------------------

	for tgtfile in bblayers local; do
		[[ "$option_proprietary" == 1 ]] && PROPFILES="${tgtfile}_proprietary.conf.inc ${TARGET}_${tgtfile}_proprietary.conf.inc"
	
		for file in ${tgtfile}.conf.inc ${TARGET}_${tgtfile}.conf.inc $PROPFILES; do
			if [[ -f $SRCDIR/$file ]]; then
				info "=== conf: $file -> ${tgtfile}.conf"
				sed "s|@METADIR@|$DSTDIR/meta|g" <$SRCDIR/$file >conf/$file
			else
				info "=== conf: $file is empty"
				touch conf/$file
			fi
			grep "^require conf/$file" conf/${tgtfile}.conf &>/dev/null || echo "require conf/$file" >>conf/${tgtfile}.conf
		done
	done

popd >/dev/null #}

cat <<EOF
=====================================================================

Build environment is ready. To use it, run:

# source $DSTDIR/meta/poky/oe-init-build-env $DSTDIR/build 

then

# bitbake agl-demo-platform

=====================================================================
EOF


